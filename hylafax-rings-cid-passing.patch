# This patch is pretty rough.  It
# creates persistent copy of CID information (called received_cid) to stop
# the loss of this information with subsequent ring detects after CID
# presentation from the switch.  received_cid is then used for CID
# checking when answering is to take place.  I also made received_cid the
# information that was logged because then we have some confidence that
# our log actually shows what we are basing the CID checking on.
#
# The patch is incomplete as I didn't deal with cid handling in the
# faxGettyApp::answerphonecmd method.  I'm not convinced that CID handling
# was fully thought through in that part of the code anyway.  I'm not
# exactly sure how CID is supposed to affect a forced call answer...  it
# would seem that it has been coded for CID screening a call even if there
# is a specific request to answer it with answerphonecmd.  If this is how
# it is supposed to work, then the code is broken and will fail  (because
# answerphonecmd can be executed prior to CID presentation from the switch
# or prior to any ring detection and no CID info = rejected call.)  If
# it's not how the code is supposed to work then I don't really know
# what's going on. - Campbell McKilligan <cowboycam@2die4.com>
#
--- faxd/faxGettyApp.h.orig	Sun Apr 22 21:51:49 2001
+++ faxd/faxGettyApp.h	Sun Apr 22 21:53:18 2001
@@ -71,6 +71,7 @@
     time_t	lastCIDModTime;		// last mod time of CID patterns file
     RegExArray*	cidPats;		// recv cid patterns
     fxBoolArray* acceptCID;		// accept/reject matched cid
+    CallerID	received_cid;		// CID that was received that was not null
     fxStr	gettyArgs;		// getty arguments
     fxStr	vgettyArgs;		// voice getty arguments
     fxStr	egettyArgs;		// extern getty arguments
--- faxd/faxGettyApp.c++.orig	Sun Apr 22 21:53:49 2001
+++ faxd/faxGettyApp.c++	Sun Apr 22 21:58:04 2001
@@ -184,6 +184,8 @@
 	changeState(LISTENING);
 	sendModemStatus("B");
 	ringsHeard = 0;
+	received_cid.name = "";
+	received_cid.number = "";
 	listenForRing();
     } else if (state != SENDING && state != ANSWERING && state != RECEIVING) {
 	/*
@@ -215,14 +217,15 @@
     CallType ctype = ClassModem::CALLTYPE_UNKNOWN;
     if (modemWaitForRings(1, ctype, cid)) {
 	if (cid.number != "" || cid.name != "") {
+	    received_cid = cid;
 	    traceServer("ANSWER: CID NUMBER \"%s\" NAME \"%s\"",
-		(const char*) cid.number, (const char*) cid.name);
+		(const char*) received_cid.number, (const char*) received_cid.name);
 	    faxApp::sendModemStatus(getModemDeviceID(), "C\"%s\"%s\"",
-		(const char*) cid.number, (const char*) cid.name);
+		(const char*) received_cid.number, (const char*) received_cid.name);
 	}
 	++ringsHeard;
 	if (ringsBeforeAnswer && ringsHeard >= ringsBeforeAnswer)
-	    answerPhone(ClassModem::ANSTYPE_ANY, ctype, cid);
+	    answerPhone(ClassModem::ANSTYPE_ANY, ctype, received_cid);
 	else
 	    // NB: 10 second timeout should be plenty
 	    Dispatcher::instance().startTimer(10, 0, &answerHandler);
